'''
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
'''
# 这个问题与斐波那契数列类似，因为到达每个阶梯的方法数都是前两个阶梯方法数的和。我们可以使用一个动态规划表（或简单的几个变量）来保存每个阶梯层的方法数量，然后基于之前的计算结果来递推出下一阶梯的方法数。
class Solution:
    def climbStairs(self, n: int) -> int:
        # 如果楼梯阶数少于或等于1，直接返回n（因为n阶有n种方法）
        if n <= 1:
            return n
        
        # 初始化dp数组，dp[i]代表到达第i阶有多少种方法
        # 基本情况，第1阶有1种方法，第2阶有2种方法
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        
        # 从第3阶开始计算每一阶的爬楼方法
        for i in range(3, n + 1):
            # 状态转移方程：第i阶的方法数是前两阶方法数之和
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # 返回达到第n阶的方法数
        return dp[n]

# 用例测试
sol = Solution()
print(sol.climbStairs(5))  # 输出应该是8
